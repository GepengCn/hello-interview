在Java中，当你重写`equals`方法时，通常也需要重写`hashCode`方法，这是由于`equals`和`hashCode`方法在HashMap以及Java集合框架中的其他部分的工作方式密切相关。以下是重写`hashCode`方法的原因：

### 1. 哈希表的工作原理

HashMap使用哈希码来存储和查找键值对。当你插入或查找一个键时，HashMap首先计算其哈希码，然后根据这个哈希码决定数据应该存储在哪个桶中。

### 2. `equals`和`hashCode`的契约

Java中的`Object`类定义了`equals`和`hashCode`方法的契约：

- **相等对象必须有相同的哈希码**：如果两个对象根据`equals`方法是相等的，那么它们的`hashCode`方法必须返回相同的整数值。
- **不相等的对象可以有相同的哈希码**：但是，为了哈希表的性能，最好尽量减少这种情况的发生。

### 3. 保持一致性

如果你重写了`equals`方法而没有重写`hashCode`方法，那么可能违反了上述契约。这是因为默认的`hashCode`方法（继承自`Object`类）可能对于逻辑上相等的对象返回不同的哈希码。这会导致HashMap无法正确地存储和查找这些对象，因为相等的对象可能被分配到哈希表的不同位置。

### 4. HashMap的正确行为

为了确保HashMap能够正确地存储和查找键值对，键对象的`equals`和`hashCode`方法必须一致地实现。这意味着如果两个键对象通过`equals`方法判断相等，它们的哈希码也必须相同，从而确保它们会被存储在相同的桶中，并且在查找时可以正确匹配。

### 示例场景

假设有两个键对象`key1`和`key2`，它们在逻辑上是相等的（即`key1.equals(key2)`返回`true`）。如果只重写了`equals`而没有重写`hashCode`，可能会导致`key1`和`key2`有不同的哈希码。这样，在使用这些键存储数据到HashMap时，即使它们代表相同的键，也可能被存储在不同的位置，导致数据的不一致性和查找错误。

因此，为了确保HashMap及类似数据结构的正确性和性能，重写`equals`方法时也应该相应地重写`hashCode`方法。